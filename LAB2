import random

# Step 2: Initialize Parameters
POP_SIZE = 6             # Number of individuals in the population
GENES = 5                # Number of genes per chromosome (5 bits = 0 to 31)
GENERATIONS = 5          # Number of generations to run
CROSSOVER_RATE = 0.7     # Probability of crossover
MUTATION_RATE = 0.1      # Probability of mutation per gene

# Step 1: Define the Problem
# Optimization function: f(x) = x^2 (maximize)
def fitness(x):
    return x * x

# Step 3: Initialize Population (each gene is a bit string of length GENES)
def create_population():
    population = []
    for _ in range(POP_SIZE):
        genes = ''.join(random.choice('01') for _ in range(GENES))
        population.append(genes)
    return population

# Step 8: Gene Expression - Decode binary gene to integer x
def express_gene(gene_sequence):
    return int(gene_sequence, 2)

# Step 4: Evaluate Fitness
def evaluate_population(population):
    return [fitness(express_gene(ind)) for ind in population]

# Step 5: Selection - Tournament Selection
def tournament_selection(population, fitness_values):
    i1, i2 = random.sample(range(len(population)), 2)
    return population[i1] if fitness_values[i1] > fitness_values[i2] else population[i2]

# Step 6: Crossover - Single-point crossover
def crossover(parent1, parent2):
    if random.random() < CROSSOVER_RATE:
        point = random.randint(1, GENES - 1)
        child1 = parent1[:point] + parent2[point:]
        child2 = parent2[:point] + parent1[point:]
        return child1, child2
    else:
        return parent1, parent2

# Step 7: Mutation - Bit flip mutation
def mutate(individual):
    mutated = ''
    for bit in individual:
        if random.random() < MUTATION_RATE:
            mutated += '1' if bit == '0' else '0'
        else:
            mutated += bit
    return mutated

# Step 9: Main Loop
def gene_expression_algorithm():
    population = create_population()
    best_solution = None
    best_fitness = -1

    for gen in range(1, GENERATIONS + 1):
        fitness_values = evaluate_population(population)

        # Track best individual
        for i in range(len(population)):
            if fitness_values[i] > best_fitness:
                best_fitness = fitness_values[i]
                best_solution = population[i]

        # Print best of this generation
        x_val = express_gene(best_solution)
        print(f"Generation {gen}: Best = {best_solution} (x = {x_val}), Fitness = {best_fitness}")

        # Generate new population
        new_population = []
        while len(new_population) < POP_SIZE:
            parent1 = tournament_selection(population, fitness_values)
            parent2 = tournament_selection(population, fitness_values)
            child1, child2 = crossover(parent1, parent2)
            child1 = mutate(child1)
            child2 = mutate(child2)
            new_population.extend([child1, child2])

        population = new_population[:POP_SIZE]

    # Step 10: Output Best Solution
    final_x = express_gene(best_solution)
    print(f"\nBest solution found: {best_solution} (x = {final_x}), Fitness = {best_fitness}")

# Entry Point
if __name__ == "__main__":
    gene_expression_algorithm()
